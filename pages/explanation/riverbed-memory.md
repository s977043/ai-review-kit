# Riverbed Memory (ドラフト)

## 概要

Riverbed Memory はコンテキストが定着する場所である。川底が過去の流れの痕跡を保持するように、アーキテクチャ上の決定、WontFix 項目、過去のレビュー結果を記憶し、River Reviewer が PR やリリース間で一貫性を保てるようにする。流れを安定させる、軽量で監査可能な記憶層と考える。

## スコープ (v0 → v1 → v2)

- **v0: ステートレス (現在)**—永続化されたコンテキストはなく、各レビューは独立している。
- **v1: 最小限のメモリ**—PR コメントに構造化されたメタデータを埋め込むか、次の実行のための決定/リンクをキャプチャする実行ごとの JSON アーティファクトを保存する。
- **v2: 外部化されたメモリ (スケッチ)**—リポジトリ間の想起や長期間の履歴を必要とするチーム向けの、オプションの Postgres/Redis/ベクターストア バックエンド。

## ストレージオプション

- **隠しマーカー付き GitHub PR コメント**: 検査が容易で、再実行でも残る。サイズに制限があり、ノイズの多い通知を避ける必要がある。
- **GitHub Artifacts (PR ごとの .json)**: 安価で監査可能。スナップショットに適しているが、保持ポリシーにより期限切れになる。
- **`.river/` 配下のリポジトリファイル**: コードと一緒に配置され、バージョン管理される。頻繁に書き込まれるとチャーンやマージ競合が発生する可能性がある。
- **外部データストア (Postgres/Redis/vector DB)**: スケーラブルで意味的な想起を可能にする一方、運用のオーバーヘッドとシークレット管理が追加される。

## 設計トレードオフ

- **コスト**: コメントは無料、アーティファクトは安価、外部ストアはインフラコストが発生する。
- **複雑さ**: コメント/アーティファクトは単純。リポジトリファイルは書き込みパスとマージ戦略が必要。外部 DB はサービスとローテーションが必要。
- **セキュリティ**: コメント/アーティファクトは GitHub スコープ内に存在。リポジトリファイルはリポジトリ ACL を継承する。外部ストアはシークレット処理とネットワークポリシーが必要。
- **監査可能性**: コメントとリポジトリファイルは人間が読める。アーティファクトは検索可能。外部ストアは明示的な保持/バックアップが必要。

## 次のアクション (v1 に向けて)

1. JSON にシリアル化できる最小限のメモリレコードスキーマ（例: Issue ID、ADR リンク、または WontFix の根拠）を定義する。
2. レコードをアーティファクトとして出力し、許可されている場合は隠しマーカー付きのコンパクトな PR コメントを出力するオプションの GitHub Action ステップを追加する。
3. エージェントに、各実行で最後に利用可能なアーティファクト/コメントを取り込み、レビューをブロックすることなくプロンプトコンテキストにマージするように教える。
